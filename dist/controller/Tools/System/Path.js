"use strict";var __importDefault=this&&this.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(exports,"__esModule",{value:!0});const fs_1=require("fs"),promises_1=require("fs/promises"),path_1=require("path"),archiver_1=__importDefault(require("archiver"));class Path{directory;options;ignores;constructor(i,t){if(this.directory=(0,path_1.resolve)(i),this.options=t,!(0,fs_1.existsSync)(this.directory)||!(0,fs_1.lstatSync)(this.directory).isDirectory()){if(!this.options?.force)throw new Error(`Can't found "${this.directory}" directory, use force options to create`);(0,fs_1.mkdirSync)(this.directory,{recursive:!0})}this.go=this.go.bind(this),this.back=this.back.bind(this),this.make=this.make.bind(this),this.scan=this.scan.bind(this),this.copy=this.copy.bind(this),this.move=this.move.bind(this),this.clear=this.clear.bind(this),this.ignore=this.ignore.bind(this),this.compress=this.compress.bind(this),this.inIgnores=this.inIgnores.bind(this)}go(i){i=(0,path_1.join)(this.directory,i);if((0,fs_1.lstatSync)(i).isDirectory())return this.directory=i,this;throw new Error(`Not found ${i} directory`)}back(i=1){var t=this.directory.split(path_1.sep);return this.directory=t.slice(0,t.length-i).join(path_1.sep),this}make(i){return(0,fs_1.mkdirSync)((0,path_1.join)(this.directory,i),{recursive:!0}),this.go(i)}ignore(i){return this.ignores=i,this}inIgnores(t){return!!this.ignores&&!!this.ignores.find(i=>t.startsWith(i)||"*"+(0,path_1.extname)(t)===i)}async scan(i,t=this.directory,s){for(const o of await(0,promises_1.readdir)(t)){var r,e=s?s+"/"+o:o,a=(0,path_1.join)(t,o);this.inIgnores(e)||((r=(0,fs_1.lstatSync)(a).isDirectory())&&await this.scan(i,a,e),await i({isDirectory:r,subPath:e,fullPath:a}))}}async clear(){await this.scan(async({isDirectory:i,fullPath:t})=>{i&&0===(0,fs_1.readdirSync)(t).length?await(0,promises_1.rmdir)(t):i||await(0,promises_1.unlink)(t)}),0===(0,fs_1.readdirSync)(this.directory).length&&await(0,promises_1.rmdir)(this.directory)}async copy(r){const e=(0,path_1.resolve)(r);await(0,promises_1.mkdir)(e,{recursive:!0}),await this.scan(async({isDirectory:i,subPath:t,fullPath:s})=>{i||s.startsWith(e)||(i=(0,path_1.dirname)((0,path_1.join)(r,t)),(0,fs_1.existsSync)(i)||await(0,promises_1.mkdir)(i,{recursive:!0}),await(0,promises_1.copyFile)(s,(0,path_1.join)(r,t)))})}async move(i){await this.copy(i),await this.clear()}async compress(i){const r=(0,path_1.resolve)(i);await(0,promises_1.mkdir)((0,path_1.dirname)(r),{recursive:!0});i=(0,fs_1.createWriteStream)(r);const e=(0,archiver_1.default)("zip",{zlib:{level:9}});e.pipe(i),await this.scan(async({isDirectory:i,subPath:t,fullPath:s})=>{i||s.startsWith(r)||e.file(s,{name:t})}),await e.finalize()}}function path(i=".",t){return new Path(i,t)}exports.default=path;